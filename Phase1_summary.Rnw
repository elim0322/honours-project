\documentclass[a4paper]{article}
    \parindent=1em
    \usepackage[font=footnotesize, labelfont=bf]{caption} % bold caption
    %\usepackage[usenames,dvipsnames]{color} % not compatible with knitr yet..
    \usepackage{xcolor} % highlighting.
    \usepackage{enumerate}
    \usepackage{listings} % fancyvrb doesn't have word wrap..
        \lstset{
            basicstyle=\small\ttfamily,
            columns=flexible,
            breaklines=true,
            captionpos=t, % sets the caption-position to bottom
            numbers=left, % line numbers on the left
            frame=single, % adds a frame around the code
            fontadjust=true
            escapechar=|
            language=HTML
        }
    \usepackage{url}
    \usepackage{tikz}
    \usepackage{hyperref}
    \usetikzlibrary{shapes.geometric, arrows}
    \usepackage[export]{adjustbox} % better image alignment & scale

%%%%% flow chart configuration %%%%%
\tikzstyle{simple} = [rectangle, rounded corners, text width=3cm, text centered, draw=black, align=center]
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, text width=3cm, draw=black, fill=orange!20]
\tikzstyle{decision} = [diamond, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzstyle{line} = [thick,-,>=stealth]

\title{\textbf{Introduction to Knitr Round Trip: Phase 1 Summary}}
\author{Eric Lim}
\date{\today}

\begin{document}
  \maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:introduction}
<<setup, echo=FALSE>>=
opts_chunk$set(comment = NA, prompt = TRUE, tidy = FALSE, background='white')
options(prompt = "R> ")
knit_theme$set("print")
@

\textbf{knitr} is a wonderful package that enables dynamic report generation with R. It allows us to implement R code into LaTeX, LyX, HTML, Markdown, AsciiDoc, and reStructuredText documents through the concepts of literate programming, which involves interaction between code and documentation for report generation. The main purpose of \textbf{knitr} follows an important idea in academic research that the ideal report should include the computational environment used for the research such as code and data which can reproduce results (reproducible research).

\begin{figure}[h]
\centering
  \begin{tikzpicture}[node distance=3cm]
    \node(in)[simple]{Source document \\ (input)};
    \node(out)[simple, right of=in, xshift=2.5cm]{Final document \\ (output)};
    \draw[arrow](in)--node[anchor=south]{\textbf{knitr}}(out);
  \end{tikzpicture}
  \caption{Unidirectional process of generating final documents}
  \label{fig:flow1}
\end{figure}

While there are tremendously important ideas to consider and many advantages, the process of generating R code embedded documents using \textbf{knitr} is almost always a one-way trip (Figure \ref{fig:flow1}), meaning source documents (as input) can only generate final documents (as output), not the other way around. This is simply due to the fact that \textbf{knitr} is designed with intention to dynamically generate reports, not to extract displayed R code in final documents to generate source documents. There may be a few limitations, caused by this property, that we will explore further.

Consider a situation where a person who provides documents (using \textbf{knitr}) and another who reads or reviews the documents are involved. In this situation, it is often difficult for the document provider to receive feedback from the reviewer efficiently and make appropriate changes. Since it is impossible to go back from final documents to source documents, the reviewer would have to provide his or her feedback by either writing physically on the printed version of the final report or by electronic means such as through e-mails. The document provider, then, has to rectify the source documents accordingly, and repeat the process of generating and presenting the report to the reviewer. This process often has to be repeated until final correction can be achieved. As we can see, it can quickly become tedious.

We believe this is relevant to the field of statistics as similar situations mentioned above can often arise. Interaction between clients and consultants is fundamentally important for statisticians and any possible factor to deteriorate the relationship with clients is best avoided. Therefore, we want to avoid this issue by a more efficient way to generate final documents.

A possible solution is to allow reviewers to interact directly with the final documents to edit them. Then the document provider can see the changes made by the reviewer and discuss those changes more efficiently. Furthermore, to take reproducible research into account it would be best to find a way to generate a new source document based on the edited final document (so the newly edited final reports can be reproducible). To achieve this solution, there must be a way to enable final documents to be converted to source documents. In other words, the one-way trip from source documents to final documents must incoporate another trip from the final to source documents.

The project we are working on has its main focus on making this ideal round trip possible, and if not what possible issues prevent this from happening. For a start, we deal with simple HTML documents in the hopes of finding a more generalised approach for our goal.

Before proceeding further into more detailed look at the round trip, here is a brief illustration of how an HTML source document in the Rhtml format can produce the final HTML document.

Below is the code structure of the source document, ``example1.Rhtml". We can notice from the lines 9--11 that a line of R code (line 10) is enclosed in a special comment tag.

\definecolor{c}{HTML}{FAA21A}
\newcommand{\hl}[3][black]{{\fboxsep0.5pt\colorbox{#2}{\color{#1} #3}}}
\begin{lstlisting}[caption={example1.Rhtml}, escapechar=\|, label={lst:1}]
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
    |\hl{c}{<!--begin.rcode}|
    |\hl{c}{rnorm(20)}|
    |\hl{c}{end.rcode-->}|
    </body>
</html>
\end{lstlisting}

The following code calls the function, \texttt{knit()}, on the above Rhtml document, and the document is ``knitted" to generate the final document, ``example1.html".
<<eval=FALSE>>=
library(knitr)
knit("example1.Rhtml")
@

Listing \ref{lst:2} shows the structure of the final document, "example1.html". The R code chunk has been modified (lines 14--20) to match the HTML syntax and be processed as a part of the HTML document. The original line of R code (from line 10 of Listing \ref{lst:1}) is still noticeable (red coloured text in Listing \ref{lst:2}). The output from the R code is in lines 16--18 in Listing \ref{lst:2}.
\begin{lstlisting}[caption={example1.html}, escapechar=\|, label={lst:2}]
<!DOCTYPE html>
<html>
  <head>
<style type="text/css">
.knitr.inline {
    ...about 58 lines of styles defined by knitr...
}
</style>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">|\hl{c}{rnorm}|</span><span class="hl std">|\hl{c}{(}|</span><span class="hl num">|\hl{c}{20}|</span><span class="hl std">|\hl{c}{)}|</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1] -0.326450  0.868096  0.109990  0.555811  0.961545  0.200446  0.352004
##  [8] -0.009584 -0.132941  1.233210  0.656319  1.166483  0.238306  2.137970
## [15]  1.268752 -0.808173  0.207059 -0.734526  0.820859  1.248322
</pre></div>
</div></div>

  </body>
</html>
\end{lstlisting}

Figure \ref{fig:1} shows what ``example1.html" will look like in a browser.
\begin{figure}[h]
\includegraphics[trim=0cm 20cm 0cm 0cm,clip=true,width=1.3\textwidth,center]{example1}
\caption{example1.html in a browser}
\label{fig:1}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Overview
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Overview}
\label{sec:overview}
\begin{figure}[h!]
  \begin{tikzpicture}[node distance=2.2cm]
    \node(start)[startstop]{untitled.Rhtml};
    \node(sew)[process, below of=start]{untitled.post.Rhtml};
    \node(knit)[process, below of=sew]{untitled.post.html};
    \node(snap)[process, below of=knit]{untitled.edit.html};
    \node(browser)[simple, right of=snap, xshift=2cm]{browser:\\upload, edit, save};
    \node(anno)[process, below of=snap]{untitled.anns.html};
    \node(chgs)[process, below of=anno]{untitled.save.html};
    \node(rip)[startstop, below of=chgs]{untitled.return.Rhtml};
    \node(repeat)[decision, left of=knit, xshift=-3cm]{Repeat};
    \draw[arrow](start)--node[anchor=west] {i.\texttt{sew()}} (sew);
    \draw[arrow](sew)--node[anchor=west] {ii.\texttt{knit()}} (knit);
    \draw[arrow](knit)--node[anchor=west, pos=0.4] {iii.\texttt{snap()}} (snap);
    \draw[arrow](snap)--node[anchor=west, pos=0.6] {iv.\texttt{annotations()}} (anno);
    %
    %\draw[arrow] (snap) to [out = 30, in = 120, looseness = 1] (browser);
    \draw[arrow] (snap) to [bend left = 30] (browser);
    \draw[arrow] (browser) to [bend left = 30] (snap);
    %
    \draw[arrow](anno)--node[anchor=west]{v.\texttt{changes()}} (chgs);
    \draw[arrow](chgs)--node[anchor=west] {vi.\texttt{rip()}} (rip);
    \draw[line, dashed](rip)-|(repeat);
    \draw[arrow, dashed](repeat)|-(start);
  \end{tikzpicture}
\caption{Steps involved in the round trip. The source document (``untitled.Rhtml") goes through each step until it reaches the final destination (``untitled.return.Rhtml"). The final return.Rhtml file can be fed through the process again if additional changes are required.}
\label{flow:2}
\end{figure}

The flow chart in Figure \ref{flow:2} outlines a series of steps involved in our hypothesised round trip. A brief description for each step is as follows:
\begin{enumerate}[i]
\item The function \texttt{sew()} is called on the Rhtml (source) document to generate a post.Rhtml file. As we have seen in Listing \ref{lst:2}, the original R code is heavily modified by \textbf{knitr} as the final document is generated. We must preserve the original R code so that it can be ``reproduced" or reappear in the new source document generated from the round trip.

In order to preserve the original R code chunks, each chunk is copied and inserted next to the original with a marker. This marker will be explained more in detail but their primary purpose is to allow separate detection of the original and copy. After all the chunks of R code present in the source document are copied and correctly inserted, the post.Rhtml document is prepared for the next step.

\item The post.Rhtml document is knitted to produce a post.html document which retains the copies of the original R code chunks. Note that these copies are not displayed as they are hidden inside HTML comment tags while the information of the original R code is retained in the successive steps. The copies will not be interfered until the very last step of the round trip.

\item Through the function \texttt{snap()} a few lines of code are appended in the knitted document ``untitled.post.html" to enable the features of text editing. All parts of the document can be edited through a browser-integrated text editor called \textbf{CKEditor} once the resulting document ``untitled.edit.html" is uploaded on our server. The R related sections of the document such as the displayed R code and any output from R are controlled to be annotated only through an engine called \textbf{AnnotateIt}. Any changes and annotations made on the document can be saved into text files (via a method involving PHP) which serve as primary input for the next step.

\item Any annotations made during the previous editing step are processed and inserted at the top lines of the corresponding R code chunks with the information on \emph{which} text is annotated with \emph{what} annotations by \emph{who}. The inserted annotations are highlighted to further improve visual awareness. Once all the annotations are processed, an anns.html file is created for the next step.

\item Similarly to the previous annotations step, any changes made on ``untitled.edit.html" are read in and the old, unwanted lines of text are replaced accordingly with the new lines of text. Then, the resulting document is saved as a save.html file for the final step.

\item \texttt{rip()} is the function involved in the ``final" step of the round trip. As the name ``rip" suggests, any additional lines of code inserted during the round trip are removed, essentially to match the format of the source document. Moreover, the lines added by \textbf{knitr} itself (such as code for its pre-defined style) are also removed. The copies of R code (from \texttt{sew()}) are text-processed to be wrapped inside the appropriate comment tags (lines 9 and 11 in Listing \ref{lst:1}) required by \textbf{knitr}.

\end{enumerate}

The final document can be repeatedly fed through the steps of the round trip for additional editing. The overall execution of all the steps involved in the round trip may seem unnecessary but it can definitely improve the efficient communication between the previously mentioned document provider and reviewer.

Ideally the reviewer edits directly on the post.html document prepared by the document provider and saves the changes. Then the document provider can re-generate the source document with appropriate changes which can be knitted again to produce another post.html document for extra editing.

Much detail is omitted for the purpose of the overview. Important assumptions and more detailed discussion of these functions involved in the round trip will be introduced in section \ref{sec:functions}.


\section{Functions}
\label{sec:functions}
Throughout the project, many important assumptions have emerged from time to time which have played an important role in improving the robustness of our methodology on the completion of the round trip. These assumptions should be regarded as 
Therefore, it is absolutely necessary to mention them along with more detailed discussion on the reasoning behind the logic of our functions.

\subsection{\texttt{sew()}}
As a reminder we can refer back to Listing \ref{lst:1} and note the way R code is presented. As we examine the highlighted lines (9 and 11 especially), we should notice that \textbf{knitr} requires R code chunks to be wrapped inside obscurely modified HTML comment tags (lines 9 and 11) which can only be recognised and processed by \textbf{knitr}. Upon realising this method used by \textbf{knitr}, our immediate response was to use a similar algorithm to approach the hypothesized round trip.

One of the most important ideas to constantly remind ourselves was the preservation of the original R code. As briefly mentioned in section \ref{sec:overview}, retaining the exactly identical R code (that we started with) is a fundamentally important aspect of the round trip to reproduce the identical source document. If we were to edit final documents directly, the sections of any R related contents cannot be directly modified due to the unidirectional property of \textbf{knitr} (as we have explored in section \ref{sec:introduction}) and therefore can only be annotated, it is essential that the round trip implements a methodology for the retention of the original R code. 

We have decided to implement a similar algorithm involving HTML comment tags through which the retention of the original R code is possible. The algorithm we have formulated is to (exactly) copy the original chunks of R code and insert the copies next to the originals. This is essentially carried out by \texttt{sew()}.

The following command in R calls \texttt{sew()} on ``example1.Rhml" to generate ``example1.post.Rhtml".
<<eval=FALSE>>=
source("sew.R")
sew("example1.Rhtml")
@

The lines of text coloured green in Listing \ref{lst:3} represent the copy of the original R code chunk. Comparing with the structure of the initial source document (Listing \ref{lst:1}), the two documents are identical, except for the green-coloured section to suggest that only the copy of the original R code is inserted and no other sections are unintentionally changed by the function \texttt{sew()}.

A slight deviation can be observed in line 12 (compared to the ``original" line 9) which is our intention so that the copies are easily identifiable. The algorithm is effective in the way that \textbf{knitr} does not detect our copies while we can control what to do with them in the subsequent steps. More specifically, the replacement of the character ``r" by the text ``keep" in line 12 separates this copy from the original R code chunk so that \textbf{knitr} is unable to recognize the pattern for conversion. This allows the copy to remain as comments in the HTML syntax which can only be examined through the internal code structure of the document (not displayed in a browser). Furthermore, this difference can be indentified without difficulty to allow for robust control over these copies.

In consequence, the copies cannot be interfered by \textbf{knitr} (which is perfect for our goal of preserving the R code) and they are not displayed in the final document for reproducibility. Unless we specifically decide to remove the copies, they remain untouched throughout the round trip until the final stage involving the conversion of these copies into their corresponding originals.
\begin{lstlisting}[caption={example1.post.Rhml}, escapechar=\|, label={lst:3}]
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
    <!--begin.rcode
    rnorm(20)
    end.rcode-->
    |{\color{green}<!--begin.keepcode}|
    |{\color{green}rnorm(20)}|
    |{\color{green}end.rcode-->}|
  </body>
</html>
\end{lstlisting}

The resultant document ``example1.post.Rhtml" can be knitted to produce ``example1.post.html" whose internal structure can be seen in Listing \ref{lst:4}. The highlighted lines show that the copy of the original R code chunk remains untouched by the knitting procedure, and is hidden from the display via a browser (Figure \ref{fig:2}). Notice Figure \ref{fig:1} and \ref{fig:2} are identical (except the randomly generated values).

The R code chunk in ``example1.post.html" can be observed from the lines 12--18. Notice that the R code chunk is divided into two nested div elements with the class attributes \texttt{"rcode"} and \texttt{"output"} respectively. Nonetheless the whole R code chunk is inside the div element with a class attribute named \texttt{"chunk"} to potentially permit robust control over this chunk.

\begin{lstlisting}[caption={example1.post.Rhml}, escapechar=\|, label={lst:4}]
<!DOCTYPE html>
<html>
  <head>
<style type="text/css">
    ...lines inserted by knitr
</style>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">20</span><span class="hl std">)</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1]  0.21997 -1.02766  1.22804  0.78368 -0.09822 -1.41733  0.25276
##  [8] -0.89354  0.01876  2.55360 -0.46999  1.14496  0.57621 -0.12584
## [15] -0.40660 -1.74065  0.27885  0.90726 -0.97394  0.62497
</pre></div>
</div></div>

    |\hl{c}{<!--begin.keepcode}|
    |\hl{c}{rnorm(20)}|
    |\hl{c}{end.rcode-->}|
  </body>
</html>
\end{lstlisting}

\begin{figure}[h]
\includegraphics[trim=0cm 20cm 0cm 0cm,clip=true,width=1.3\textwidth,center]{example1_post}
\caption{example1.post.html in a browser}
\label{fig:2}
\end{figure}

The output HTML document from \texttt{sew()} (``example1.post.html) is available to be edited and annotated. As long as our intention remains not to interfere with the copies of R code chunks, these copies are safely reserved in the document. That is, the following step of enabling the document to be edited and annotated does not affect the copies in any way.

\subsection{\texttt{snap()}}
Our primary goal is to edit directly on the HTML document that \texttt{knit()} produces. In general, HTML documents are most often viewed through a browser. The essential purpose of HTML documentation and coding itself lies in the presentation of information through a browser (as opposed to that of XML being the containment of information) which has led us to formulate an algorithm in conjunction with browsers. One of the most natural programming languages extensively used for browsers and browser-integrated applications can be considered JavaScript. From seraching through resources, an open source engine (coded in JavaScript) named \textbf{CKEditor} has been available to us for testing. \textbf{CKEditor} is a browser-integrated text editor that incorporates editable environment on website contents. Once enabled, an editable environment familiar to most document editors is intergrated to the browser and the contents of the website being browsed become editable. A demonstration of \textbf{CKEditor} can be viewed at \url{http://ckeditor.com/demo}.

As mentioned previously, the restriction of \textbf{knitr}'s unidirectional document generation has a tremendous impact on the parts of documents associated with R. It is pointless to edit R code chunks on the final documents as any changes made on the R code will not be processed by R for regenerating the document with new results. Editing the R code chunks will only result in text-based modification and will not have any impact on the results processed by the R code. Since the contents relating to chunks of R code can (should) not be editable, our solution is to allow them to be annotated. Through the use of annotations, the R-related contents are protected from direct modification while effectively delivering the message from the annotations to the viewer. Our decision to allow annotations on the R contents has led us to test another open source engine, named \textbf{AnnotateIt}, specifically developed for annotations on selected parts of website contents. A possible restriction with using \textbf{AnnotateIt} may be its requirement for users to be logged in on their webiste (\url{http://annotateit.org}). Despite this, it has been tested to be fairly reliable and meet satisfactory standards of our purpose.

These two open source engines are browser-integrated, meaning they can only be utilized on website contents (i.e. uploaded HTML documents on servers) via browsers. In other words, we must use browsers to view documents that we wish to edit and annotate through which these two engines to be available. ** We cannot simply view them offline for these two modules to be fully functional **. Therefore, any HTML documents to be edited and annotated must be uploaded onto a server through which \textbf{CKEditor} and \textbf{AnnotateIt} are both fully functional. Thus, it has been decided to integrate a test server into our project. The document that we wish to be able to edit and annotate (for example, ``example1.post.html") is uploaded manually (using keyboard and mouse) onto the test server as an initial step so that the two engines (\textbf{CKEditor} and \textbf{AnnotateIt}) are correctly called and enabled for the browser. To enhance efficiency, a method to automate the uploading procedure via an R package named \textbf{httr} (using the function \texttt{POST()}) has been applied. However, complications between \texttt{POST()} and \textbf{CKEditor} have resulted in unreliability of the method to indicate that the manual uploading is preferred. Once the document to be edited is correctly uploaded onto our test server, \textbf{CKEditor} and \textbf{AnnotateIt} are enabled on the browser (provided that the user maintains a logged in status with \textbf{AnnotateIt}). The document can then be fully edited and the R-associated sections can be annotated.

Our task is then to save these changes so that they are available to be merged into the document. For this purpose, two supplementary functions are developed, namely \texttt{edit.js} and \texttt{button.html}. Firstly, \texttt{button.html} is a simple HTML document that contains information on how \emph{save} and \emph{submit} buttons are laid out on the document being browsed. The specific task of the buttons are defined in the JavaScript \texttt{edit.js} that is primarily written in the jQuery syntax mainly for browser support. It has several tasks assigned to carry out, one of which is to call \textbf{CKEditor} and \textbf{AnnotateIt} so that the browser has those engines enabled. Other tasks are to save any changes made on the document when \emph{save} button is clicked to a specific PHP web address as a text file. When \emph{submit} button is clicked, the browser takes us to the uploading page as well as saving the changes for optimized efficiency. Our proposed idea is that the user can simply click the \emph{submit} button after final correction on the document has been made to go back to the uploading page with ease. We should note that annotations (from \textbf{AnnotateIt}) are saved as the JSON format, which is a widely used format as an alternative to XML to transfer information between a server and application. Changes from \textbf{CKEditor} are saved in the plain text format.

Our algorithm for the editing process involves an idea that each top level element of an HTML document (elements inside the HTML body) should be editable. This idea is facilitated from the fact that \textbf{CKEditor} is reasonably robust to take nested elements into account to allow for the possibility of editing the contents of nested elements such as the div and table elements. Once all the top level elements inside the HTML body are identified, the process of determining which content to be editable can be figured out with ease. The function \texttt{snap()} utilizes the XML syntax to robustly identify all the top level elements except the R code chunks, and insert the attribute ``\texttt{contenteditable="true"}" for each of these identified elements. Through the pre-specified task coded in \texttt{edit.js}, the editable environment from \textbf{CKEditor} is executed on the corresponding contents in the browser upon clicking. Additionally, any elements of R code chunks can also be reliably identified through the use of the XML syntax. Visiting back to Listing \ref{lst:4}, the briefly mentioned idea of R code chunks being contained inside div elements can be effectively used. The last task assigned to \texttt{edit.js} is to identify any R code chunks in a document and call the \textbf{AnnotateIt} module on those chunks.


% \subsection{\texttt{annotations()}}
% \subsection{\texttt{changes()}}
% \subsection{\texttt{rip()}}
% \section{Discussion}
% In addition, possible ethical issues arising from post modification of R code and their results, after the output documents are generated, can be avoided.

% \section{Contributions}
\end{document}
