\documentclass[a4paper]{article}
    \parindent=1em
    \usepackage[font=footnotesize, labelfont=bf]{caption} % bold caption
    %\usepackage[usenames,dvipsnames]{color} % not compatible with knitr yet..
    \usepackage{xcolor} % highlighting.
    \usepackage{enumerate}
    \usepackage{listings} % fancyvrb doesn't have word wrap..
        \lstset{
            basicstyle=\small\ttfamily,
            columns=flexible,
            breaklines=true,
            captionpos=t, % sets the caption-position to bottom
            numbers=left, % line numbers on the left
            frame=single, % adds a frame around the code
            fontadjust=true
            escapechar=|
            language=HTML
        }
    \usepackage{url}
    \usepackage{tikz}
    \usepackage{hyperref}
    \usetikzlibrary{shapes.geometric, arrows}
    \usepackage[export]{adjustbox} % better image alignment & scale

%%%%% flow chart configuration %%%%%
\tikzstyle{simple} = [rectangle, rounded corners, text width=3cm, text centered, draw=black, align=center]
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, text width=3cm, draw=black, fill=orange!20]
\tikzstyle{decision} = [diamond, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzstyle{line} = [thick,-,>=stealth]

\title{\textbf{Introduction to Knitr Round Trip: Phase 1 Summary}}
\author{Eric Lim}
\date{\today}

\begin{document}
  \maketitle
%------------------------------------------------------------------------------
% Introduction
%------------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}
<<setup, echo=FALSE>>=
opts_chunk$set(comment = NA, prompt = TRUE, tidy = FALSE, background='white')
options(prompt = "R> ")
knit_theme$set("print")
@

\textbf{knitr} is a wonderful package that enables dynamic report generation with R. It allows us to implement R code into LaTeX, LyX, HTML, Markdown, AsciiDoc, and reStructuredText documents through the concepts of literate programming, which involves interaction between code and documentation for report generation. The main purpose of \textbf{knitr} follows an important idea in academic research that the ideal report should include the computational environment used for the research such as code and data which can reproduce results (reproducible research).

\begin{figure}[h]
\centering
  \begin{tikzpicture}[node distance=3cm]
    \node(in)[simple]{Source document \\ (input)};
    \node(out)[simple, right of=in, xshift=2.5cm]{Final document \\ (output)};
    \draw[arrow](in)--node[anchor=south]{\textbf{knitr}}(out);
  \end{tikzpicture}
  \caption{Unidirectional process of generating final documents}
  \label{fig:1}
\end{figure}

While there are tremendously important ideas to consider and many advantages, the process of generating R code embedded documents using \textbf{knitr} is almost always a one-way trip (Figure \ref{fig:1}), meaning source documents (as input) can only generate final documents (as output), not the other way around. This is simply due to the fact that \textbf{knitr} is designed with intention to dynamically generate reports, not to extract displayed R code in final documents to generate source documents. There may be a few limitations, caused by this property, that we will explore further.

Consider a situation where a person who provides documents (using \textbf{knitr}) and another who reads or reviews the documents are involved. In this situation, it is often difficult for the document provider to receive feedback from the reviewer efficiently and make appropriate changes. Since it is impossible to go back from final documents to source documents, the reviewer would have to provide his or her feedback by either writing physically on the printed version of the final report or by electronic means such as through e-mails. The document provider, then, has to rectify the source documents accordingly, and repeat the process of generating and presenting the report to the reviewer. This process often has to be repeated until final correction can be achieved. As we can see, it can quickly become tedious.

We believe this is relevant to the field of statistics as similar situations mentioned above can often arise. Interaction between clients and consultants is fundamentally important for statisticians and any possible factor to deteriorate the relationship with clients is best avoided. Therefore, we want to avoid this issue by a more efficient way to generate final documents.

A possible solution is to allow reviewers to interact directly with the final documents to edit them. Then the document provider can see the changes made by the reviewer and discuss those changes more efficiently. Furthermore, to take reproducible research into account it would be best to find a way to generate a new source document based on the edited final document (so the newly edited final reports can be reproducible). To achieve this solution, there must be a way to enable final documents to be converted to source documents. In other words, the one-way trip from source documents to final documents must incoporate another trip from the final to source documents.

The project we are working on has its main focus on making this ideal round trip possible, and if not what possible issues prevent this from happening. For a start, we deal with simple HTML documents in the hopes of finding a more generalised approach for our goal.

Before proceeding further into more detailed look at the round trip, here is a brief illustration of how an HTML source document in the \texttt{.Rhtml} format can produce the final HTML document.

Below is the code structure of the source document, \texttt{example1.Rhtml}. We can notice from the lines 9--11 that a line of R code (line 10) is enclosed in a special comment tag.

\definecolor{c}{HTML}{CCFF00}
\newcommand{\hl}[3][black]{{\fboxsep0.5pt\colorbox{#2}{\color{#1} #3}}}
\begin{lstlisting}[caption={\texttt{example1.Rhtml}}, escapechar=\|, label={lst:1}]
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
    |\hl{c}{<!--begin.rcode}|
    |\hl{c}{rnorm(20)}|
    |\hl{c}{end.rcode-->}|
    </body>
</html>
\end{lstlisting}

The following code calls the function, \texttt{knit()}, on the above \texttt{.Rhtml} document, and the document is ``knitted" to generate the final document, \texttt{example1.html}.
<<eval=FALSE>>=
library(knitr)
knit("example1.Rhtml")
@

Listing \ref{lst:2} shows the structure of the final document, \texttt{example1.html}. The R code chunk has been modified (lines 14--20) to match the HTML syntax and be processed as a part of the HTML document. The original line of R code (from line 10 of Listing \ref{lst:1}) is still noticeable (highlighted text in Listing \ref{lst:2}). The output from the R code is in lines 16--18 in Listing \ref{lst:2}.

\begin{lstlisting}[caption={\texttt{example1.html}}, escapechar=\|, label={lst:2}]
<!DOCTYPE html>
<html>
  <head>
<style type="text/css">
.knitr.inline {
    |\emph{...about 58 lines of styles defined by knitr...}|
}
</style>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">|\hl{c}{rnorm}|</span><span class="hl std">|\hl{c}{(}|</span><span class="hl num">|\hl{c}{20}|</span><span class="hl std">|\hl{c}{)}|</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1] -0.326450  0.868096  0.109990  0.555811  0.961545  0.200446  0.352004
##  [8] -0.009584 -0.132941  1.233210  0.656319  1.166483  0.238306  2.137970
## [15]  1.268752 -0.808173  0.207059 -0.734526  0.820859  1.248322
</pre></div>
</div></div>

  </body>
</html>
\end{lstlisting}

Figure \ref{fig:2} shows what \texttt{example1.html} will look like in a browser.
\begin{figure}[h]
\includegraphics[trim=0cm 23cm 0cm 0cm,clip=true,width=1.1\textwidth,center]{example1}
\caption{\texttt{example1.html} in a browser}
\label{fig:2}
\end{figure}

%------------------------------------------------------------------------------
% Overview
%------------------------------------------------------------------------------
\pagebreak
\section{Overview}
\label{sec:overview}

There are six main steps in a complete cycle of the round trip. Each step generally involves modification of the document to prepare it for a specific goal. Ultimately, our ideology is that the reviewer edits directly on the \texttt{.edit.html} document prepared by the document provider and saves the changes. Then the document provider can re-generate the source document with appropriate changes which can be knitted again to produce another \texttt{.edit.html} document for extra editing. The round trip can be a repeated process to allow for additional editing if required.

\begin{figure}[h!]
  \begin{tikzpicture}[node distance=2.2cm]
    \node(start)[startstop]{\texttt{.Rhtml}};
    \node(sew)[process, below of=start]{\texttt{.post.Rhtml}};
    \node(knit)[process, below of=sew]{\texttt{.post.html}};
    \node(snap)[process, below of=knit]{\texttt{.edit.html}};
    \node(browser)[simple, right of=snap, xshift=2cm]{browser:\\upload, edit, save};
    \node(anno)[process, below of=snap]{\texttt{.anns.html}};
    \node(chgs)[process, below of=anno]{\texttt{.save.html}};
    \node(rip)[startstop, below of=chgs]{\texttt{.return.Rhtml}};
    \node(repeat)[decision, left of=knit, xshift=-3cm]{Repeat};
    \draw[arrow](start)--node[anchor=west] {i.\texttt{sew()}} (sew);
    \draw[arrow](sew)--node[anchor=west] {ii.\texttt{knit()}} (knit);
    \draw[arrow](knit)--node[anchor=west, pos=0.4] {iii.\texttt{snap()}} (snap);
    \draw[arrow](snap)--node[anchor=west, pos=0.6] {iv.\texttt{annotations()}} (anno);
    %
    %\draw[arrow] (snap) to [out = 30, in = 120, looseness = 1] (browser);
    \draw[arrow] (snap) to [bend left = 30] (browser);
    \draw[arrow] (browser) to [bend left = 30] (snap);
    %
    \draw[arrow](anno)--node[anchor=west]{v.\texttt{changes()}} (chgs);
    \draw[arrow](chgs)--node[anchor=west] {vi.\texttt{rip()}} (rip);
    \draw[line, dashed](rip)-|(repeat);
    \draw[arrow, dashed](repeat)|-(start);
  \end{tikzpicture}
\caption{Steps involved in the round trip. The source document (\texttt{.Rhtml}) goes through each step until it reaches the final destination (\texttt{.return.Rhtml}). The final \texttt{.return.Rhtml} file can be fed through the process again if additional changes are required.}
\label{fig:3}
\end{figure}

\pagebreak
The flow chart in Figure \ref{fig:3} outlines a series of steps involved in our hypothesised round trip. A brief description for each step is as follows:
\begin{enumerate}[i]
\item The function \texttt{sew()} is called on the source document (\texttt{.Rhtml}) to generate a \texttt{.post.Rhtml} file.

Each R code chunk in the source document is copied with a slight change to preserve each of the original R code chunks. The goal is to compensate for the fact that the original R code is heavily modified by \textbf{knitr} as the final document is generated (refer back to Listing \ref{lst:2} as a reminder). We must preserve the original R code so that it can be ``reproduced" or reappear in the new source document generated from the round trip.

%------------------
\item The \texttt{.post.Rhtml} document is knitted to produce a \texttt{.post.html} document which retains the copies of the original R code chunks.

Note that these copies are not displayed as they are hidden inside HTML comment tags while the information of the original R code is retained in the subsequent steps. The copies will not be interfered until the very last step of the round trip.

%------------------
\item The function \texttt{snap()} is called on the \texttt{.post.html} document to produce a \texttt{.edit.html} document.

The main task carried out by \texttt{snap()} is to append a few supplementary lines of code in the \texttt{.post.html} document to enable the features of text editing and annotating. The sections of the document relating to R such as R code chunks and any output from R are restricted for annotations only while the rest of the document is entirely editable with a few possible exceptions (the reason behind this decision will be discussed in more detail later).

Once the output document (\texttt{.edit.html}) is generated (by \texttt{snap()}), it needs to be uploaded onto a server through which editing, annotating and saving the changes made are fully functional. The changes are saved as text files.

%------------------
\item The saved text file (from the previous step) contains information on any annotations made. The function \texttt{annotations()} can access this information to make appropriate changes on the \texttt{.edit.html} document to produce a \texttt{.anns.html} document.

In the output document (\texttt{.anns.html}), a message is inserted at the top of each annotated R code chunk to display \emph{which} text is annotated with \emph{what} annotations by \emph{who}.

%------------------
\item Similarly to the previous annotations step, any changes made on the \texttt{.edit.html} document are accessed through the saved text file.

The old, unwanted lines of text from the input document \texttt{.anns.html} are replaced with the corresponding new lines of text to generate a \texttt{.save.html} document.

%------------------
\item The function \texttt{rip()} is called on the \texttt{.save.html} document to produce a \texttt{.return.Rhtml} document.

The main goal of \texttt{rip()} is to ``reproduce" a new source document with the changes and annotations made the previous steps. It essentially aims to convert the \texttt{.save.html} document to match the format of the source document (\texttt{.Rhtml}). Any additional lines of code inserted during the round trip and the lines added by \textbf{knitr} (such as the lines of code for the style defined by \textbf{knitr}) are removed as the main algorithm for the reproducibility.

\end{enumerate}

Important assumptions and more detailed discussion of these functions involved in the round trip will be introduced in Section \ref{sec:functions}.

%------------------------------------------------------------------------------
% Functions
%------------------------------------------------------------------------------
\section{Functions}
\label{sec:functions}
There have been various ideas to support the logic behind the algorithms involved in the steps of the round trip. It is absolutely vital to explore deeper into each function for us to gain better understanding. The main purpose of this section is to simply discuss the role of each function in more detail in order to obtain adequate understanding of the overall project and hopefully answer any questions and uncertainties raised in the previous section.

\subsection{\texttt{sew()}}
\label{subsec:1}
One of the most important ideas to constantly remind ourselves was the preservation of the original R code. As briefly mentioned in Section \ref{sec:overview}, retaining the exactly identical R code (that we started with) is a fundamentally important aspect of the round trip in order to reproduce the identical source document. We have figured that the task of preserving the original R code would be much more difficult once the code is converted by the function \texttt{knit()}, as it would then require an extra step of text-processing on the converted R code. Gathering the original information from the converted format is unnecessary complication that we can avoid, which led us to a conclusion that the preservation should happen prior to the conversion step of \texttt{knit()}.

A possible solution is to formulate a similar strategy that the package \textbf{knitr} uses. As a reminder we can refer back to Listing \ref{lst:1} and note the way R code is presented. The original line of R code is wrapped inside slightly modified HTML comment tags (lines 9 and 11) which act as a marker to signal that the contents in these comments are intended to be displayed in the final document. In other words, the function \texttt{knit()} recognises these specific types of HTML comments and convert their contents (lines of R code) appropriately for display. The package requires the user to enclose all R code chunks intended for display in final documents in this special manner.

We have decided to implement a similar algorithm involving HTML comment tags through which the retention of the original R code is possible. The only conceptual difference between the two algorithms is in their objectives: detection of R code chunks for conversion in \textbf{knitr} and for preservation in ours. The algorithm we have formulated is to copy the original chunks of R code and insert the copies below the originals. In addition, the HTML comment tags to contain the copies are further modified so that they are explicitly controllable in later steps while avoiding detection from \texttt{knit()}. These copies remain technically as comments in the HTML syntax which can only be examined through the internal code structure of the document (hidden from display through a browser). As a result, the copies of R code chunks (generated by \texttt{sew()}) are preserved in all steps unless we decide to control them to undergo modification.

In summary, our function \texttt{sew()}:
\begin{itemize}
 \item detects any R code chunks that obey the required syntax of \textbf{knitr}, that is the chunks intended to be displayed in final documents, \\[-3ex]
  \item creates identical copies of those (original) R code chunks with altered the comment tags and \\[-3ex]
  \item inserts the copies below the corresponding R code chunks.
\end{itemize}

The following command in R calls \texttt{sew()} on \texttt{example1.Rhml} to generate \texttt{example1.post.Rhtml}.

<<eval=FALSE>>=
source("sew.R")
sew("example1.Rhtml")
@

Listing \ref{lst:3} shows the structure of the output document \texttt{example1.post.Rhtml} from \texttt{sew()}. Note that the code structures of the input document \texttt{example1.Rhtml} (Listing \ref{lst:1}) and the output document \texttt{example1.post.Rhtml} (Listing \ref{lst:3}) are identical except the highlighted text which represents the copy of the original R code (lines 9--11).

\begin{lstlisting}[caption={\texttt{example1.post.Rhml}}, escapechar=\|, label={lst:3}]
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
    <!--begin.rcode
    rnorm(20)
    end.rcode-->
    |\hl{c}{<!--begin.keepcode}|
    |\hl{c}{rnorm(20)}|
    |\hl{c}{end.keepcode-->}|
  </body>
</html>
\end{lstlisting}
%------------------------------------------------------------------------------
\subsubsection{\texttt{knit()}}
\label{subsubsec:1}

The output document \texttt{example1.post.Rhtml} from the function \texttt{sew()} is ready to undergo the knitting procedure in a sense that the resultant document \texttt{example1.post.html} (from \texttt{knit()}) will always retain the original R code.

The following code is executed in R to knit the input document \texttt{example1.post.Rhtml}...
<<eval=FALSE>>=
knit("example1.post.Rhtml")
@
...to generate the output document \texttt{example1.post.html} whose internal code structure can be examined in Listing \ref{lst:4}. Note that the highlighted lines represent that the copy of the original R code chunk which remains untouched by the knitting procedure.

\begin{lstlisting}[caption={\texttt{example1.post.Rhml}}, escapechar=\|, label={lst:4}]
<!DOCTYPE html>
<html>
  <head>
    |\emph{...lines of style from knitr}|
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>20 random variates from the standard normal distribution</p>
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">20</span><span class="hl std">)</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1]  0.21997 -1.02766  1.22804  0.78368 -0.09822 -1.41733  0.25276
##  [8] -0.89354  0.01876  2.55360 -0.46999  1.14496  0.57621 -0.12584
## [15] -0.40660 -1.74065  0.27885  0.90726 -0.97394  0.62497
</pre></div>
</div></div>

    |\hl{c}{<!--begin.keepcode}|
    |\hl{c}{rnorm(20)}|
    |\hl{c}{end.rcode-->}|
  </body>
</html>
\end{lstlisting}

Figure \ref{fig:4} shows how the document \texttt{example1.post.html} looks like in a browser. We should notice that the copy of the origiinal R code is hidden from the display and the only differences in the browser-display are the random variates.

\begin{figure}[h]
\includegraphics[trim=0cm 23cm 0cm 0cm,clip=true,width=1.1\textwidth,center]{example1_post}
\caption{\texttt{example1.post.html} in a browser}
\label{fig:4}
\end{figure}

%------------------------------------------------------------------------------
\pagebreak
\subsection{\texttt{snap()}}
\label{subsec:2}
So far, we have managed to come up with a way to execute the function \texttt{knit()} on source documents (\texttt{.Rhtml}) while preserving the original information of R code chunks. The next stage of the round trip reflects on our primary objective (of the project), that is to be able to directly edit HTML documents that \texttt{knit()} produces. Possible complications involving the restriction due to \textbf{knitr}'s unidirectional document generation (Section \ref{sec:introduction}) have led us to a decision to implement the use of annotations. Especially the sections of R-related contents in final documentation are considered pointless to be directly edited as it will only result in text-based modification and will not have any impact on generating new results from the modified code. To gain the conceptual benefits of editing as discussed in Section \ref{sec:introduction}, these sections of R-associated contents are decided to be annotated to effectively deliver necessary messages from a person (editor) to another (viewer).

The first task of the function \texttt{snap()} is designed to identify the parts of an input document that should be editable. The editable sections are identified by searching for all top level elements inside the HTML body of the input document that are not introduced by the function \texttt{knit()}. Then two special attributes are inserted into the opening tag of each of these identified, editable elements: one to serve as a marker to let us know the corresponding element is editable and the other to ``number" the editable elements so that we can deal with them in an orderly manner in later steps. The top elements of annotatable sections (the R-associated contents) are identified by their distict attributes defined by \textbf{knitr}.
After correctly identifying and marking up all the editable elements, the input document is appended with two supplementary sections of code, namely \texttt{button.html} and \texttt{edit.js}. The HTML code piece \texttt{button.html} contains definition of the designs for two HTML buttons called \texttt{save} and \texttt{submit} while the JavaScript code piece \texttt{edit.js} includes a few assigned instructions. Firstly, \texttt{edit.js} loads the \textbf{jQuery} library and two JavaScript modules named \textbf{CKEditor} and \textbf{AnnotateIt} whose respective functions are to enable browser-based editing and annotating on HTML documentation. Secondly, \texttt{edit.js} is instructed with the actions for the \texttt{save} button, which is to save any changes and annotations made via \textbf{CKEditor} and \textbf{AnnotateIt} as separate text files on a server, and for the \texttt{submit} button, which is to re-direct the browser to an uploading web page on the server (which will be discussed shortly) as well as saving the changes and annotations.

Once the input document is merged with the contents of \texttt{button.html} and \texttt{edit.js}, an \texttt{.edit.html} document is generated as the output of the function \texttt{snap()}. The resulting \texttt{.edit.html} document is then uploaded onto our test server through which the actual editing and annotating of the document occur. If we refer back to Listing \ref{lst:4}, the lines 10, 11 and 12 are the three top level elements inside the body of the HTML document. By our definition, the first two elements (lines 10 and 11), which correspond respectively to a (most important) heading and a paragraph, are editable and the third element (line 12), characterised by the attribute \texttt{class="chunk"} as an element added by \textbf{knitr}, is annotatable.

The following code is used in R to call the function \texttt{snap()} on the input document \texttt{example1.post.html} to generate the output document \texttt{example1.edit.html}.

<<eval=FALSE>>=
source("snap.R")
snap("example1.post.html")
@

Listing \ref{lst:5} exhibits the internal code structure of the output document. The highlighted text (lines 10 and 11) shows the attributes added by the function \texttt{snap()}. Note that the first attributes \texttt{contenteditable="true"} are used to let \texttt{snap()} recognise the corresponding elements as editable and the second \texttt{id="Editor"} attributes are used to mark up the elements in a sequential manner.

\begin{lstlisting}[caption={\texttt{example1.edit.html}}, escapechar=\|, label={lst:5}]
<!DOCTYPE html>
<html>
  <head>
    |\emph{...lines of edit.js...}|
    |\emph{...lines of style from knitr...}|
    <title>Example</title>
  </head>
  <body>
    |\emph{...lines of button.html...}|
    <h1 |\hl{c}{contenteditable="true"}| |\hl{c}{id="Editor-1"}|>Example</h1>
    <p |\hl{c}{contenteditable="true"}| |\hl{c}{id="Editor-2"}|>20 random variates from the standard normal distribution</p>
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">20</span><span class="hl std">)</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1]  0.21997 -1.02766  1.22804  0.78368 -0.09822 -1.41733  0.25276
##  [8] -0.89354  0.01876  2.55360 -0.46999  1.14496  0.57621 -0.12584
## [15] -0.40660 -1.74065  0.27885  0.90726 -0.97394  0.62497
</pre></div>
</div></div>

    <!--begin.keepcode
    rnorm(20)
    end.keepcode-->
  </body>
</html>
\end{lstlisting}

The \texttt{.edit.html} document is then uploaded on to the test server. The browser-display of the document, on the server, can be seen in Figure \ref{fig:5} where the top and bottom displays represent the editable and annotatable environments of \textbf{CKEditor} and \textbf{AnnotateIt} respectively. Editing occurs by each element, that is each section (of the element) must be clicked separately to bring up the editable environment. Attaching annotations requires the user to have an account with \textbf{AnnotateIt} and be logged into their website \url{http://annotateit.org/}. In addition, annotations are made on selections of text of the annotatable sections. Notice the \texttt{save} and \texttt{submit} buttons at the top of the display which can be clicked to save the changes and annotations made. It is of great importance to keep in mind that the execution of editing and annotating takes place simultaneously on the uploaded document to create two separate save files with the information on the annotations and the text-based changes when the \texttt{save} or \texttt{submit} button is clicked.

\begin{figure}[h]
\includegraphics[trim=0cm 9cm 0cm 3.5cm,clip=true,width=1\textwidth,center]{CKEditor}
\includegraphics[trim=0cm 11.5cm 0cm 3.5cm,clip=true,width=1\textwidth,center]{AnnotateIt}
\caption{\texttt{example1.edit.html}, uploaded on the server, in a browser}
\label{fig:5}
\end{figure}

In summary, the function \texttt{snap()}:
\begin{itemize}
 \item identifies and marks up all editable top level elements, present in input documents, in a sequential manner, \\[-3ex]
 \item appends the two supplementary sections of code \texttt{buttons.html} and \texttt{edit.js} into the input documents whose respective purposes are: \\[-3ex]
 %
 \begin{enumerate}[i]
  \item the provision of the designs for the two \texttt{save} and \texttt{submit} buttons and \\[-3ex]
  \item to load the \textbf{jQuery} library, enable \textbf{CKEditor} and \textbf{AnnotateIt} on editable and annotatable sections of the input documents respectively, and save the changes and annotations made through the two JavaScript modules as text files on the test server when the buttons are clicked, with an additional feature of re-directing the browser to the uploading web page when the \texttt{submit} button is clicked, and
 \end{enumerate}
 %
 \item finally generate \texttt{.edit.html} documents as the output which can then be uploaded onto the server for the actual editing and annotating of the documents to take place.
\end{itemize}

%------------------------------------------------------------------------------
\subsection{\texttt{annotations()}}
\label{subsec:3}
The information on annotations made via the JavaScript module \texttt{AnnotateIt} is accessed from the test server as a text file. The module generates the save file in the JSON format for which we have decided to use an R package called \textbf{jsonlite} to effectively deal with the file format. The save file can be directly fetched from the server by using another R package \textbf{RCurl} and can then be processed, in the manner regarding the JSON format, to generate a message for each annotation. The most informative data such as the selection of text for annotations, the author of the annotations and the annotations themselves are extracted from the save file in order to generate the message.

Figure \ref{fig:6} is a minimal demonstration of creating an annotation. The last random variate is selected to be marked with the annotation ``Example". Upon clicking the blue \texttt{Save} button on the pop-up window, a save file is created by \textbf{AnnotateIt} on the test server.

\begin{figure}[h]
\includegraphics[trim=0cm 11.5cm 0cm 3.5cm,clip=true,width=1\textwidth,center]{annotations}
\caption{annotating on \texttt{example1.edit.html}}
\label{fig:6}
\end{figure}

The following code is used in R to call the function \texttt{annotations()} on the input document \texttt{example1.edit.html} to generate the output document \texttt{example1.anns.html}.

<<eval=FALSE>>=
source("annotations.R")
annotations("example1.edit.html")
@

Listing \ref{lst:6} is the internal code structure of the output document \texttt{example1.anns.html} where the highlighted lines of text (lines 12--14) represent the message genereated according to the information from the save file. The message is in a paragraph tag with the \texttt{class="annotation"} and its own style attributes.

\begin{lstlisting}[caption={\texttt{example1.anns.html}}, escapechar=\|, label={lst:6}]
<!DOCTYPE html>
<html>
  <head>
    |\emph{...lines of edit.js...}|
    |\emph{...lines of style from knitr...}|
    <title>Example</title>
  </head>
  <body>
    |\emph{...lines of button.html}|
    <h1 contenteditable="true" id="Editor-1">Example</h1>
    <p contenteditable="true" id="Editor-2">20 random variates from the standard normal distribution</p>
|\hl{c}{<p class="annotation" style = "background-color:coral">}|
|\hl{c}{The text "-1.88681" was annotated with the message "Example" by "e.lim0322"}|
|\hl{c}{</p>}|
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">20</span><span class="hl std">)</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1] -0.21445 -0.03694  1.15209 -0.75281  0.66412 -1.14614 -0.98223
##  [8] -1.10767 -1.91184  2.00111  0.66261 -1.00241 -0.41161 -0.07720
## [15] -1.20503 -1.77474 -1.05262 -3.28418  0.76983 -1.88681
</pre></div>
</div></div>

    <!--begin.keepcode
    rnorm(20)
    end.keepcode-->
  </body>
</html>
\end{lstlisting}

Figure \ref{fig:7} shows the document \texttt{example1.anns.html} in a browser. The text highlighted in red is the message.

\begin{figure}[h]
\includegraphics[trim=0cm 19.5cm 0cm 3.2cm,clip=true,width=1.1\textwidth,center]{example1_anns}
\caption{\texttt{example1.anns.html} in a browser}
\label{fig:7}
\end{figure}

%------------------------------------------------------------------------------
\subsection{\texttt{changes()}}
\label{subsec:4}
The primary task assigned to the function \texttt{changes()} is to access the save file for the changes made through \textbf{CKEditor} from the server and replace the old, modified text (in the input document) with the new text (in the save file). This replacement takes place only for the sections that are actually edited.

Figure \ref{fig:8} illustrates a brief demonstration of how the process of editing is carried out. The first editable section, which is the heading, is left as it is while the second editable section is chosen to be edited. The original line of text ``20 random variates from..." is to be edited with the bold faced text ``20 normal random variates". When the grey \texttt{save} button is clicked, the save file of the change is created on the server which is a simple text file with the code structure as shown in Listing \ref{lst:7}.

\begin{figure}[h]
\includegraphics[trim=0cm 12cm 0cm 3.5cm,clip=true,width=1\textwidth,center]{changes}
\caption{editing \texttt{example1.edit.html}}
\label{fig:8}
\end{figure}

Note the first line in Listing \ref{lst:7}. This line corresponds to the editable element (in \texttt{example1.edit.html}) with an attribute defined as \texttt{Editor-1}, that is the line 10 in Listing \ref{lst:5}, which is the heading. As we can see the heading is ``\texttt{NOT MODIFIED}" to allow the function \texttt{changes()} to ignore this editable section  of the document. On the other hand, the line 4 displays the desired change on the second editable section.

\begin{lstlisting}[caption={\texttt{changes.txt}}, escapechar=\|, label={lst:7}]
EDITOR Editor-1 NOT MODIFIED

EDITOR Editor-2:
<strong>20 normal random variates</strong>
\end{lstlisting}

The following code is used in R to call the function \texttt{changes()} on the input document \texttt{example1.anns.html} to generate the output document \texttt{example1.save.html}.

<<eval=FALSE>>=
source("changes.R")
changes("example1.anns.html")
@

The internal code structure of the output document \texttt{example1.save.html} can be seen in Listing \ref{lst:8}. The highlighted text (line 12) shows that the old line (line 11 in Listing \ref{lst:6}) is replaced with the change (line 4 in Listing \ref{lst:7}) by \texttt{snap()} to result in a display through a browser as shown in Figure \ref{fig:9}.

\begin{lstlisting}[caption={\texttt{example1.save.html}}, escapechar=\|, label={lst:8}]
<!DOCTYPE html>
<html>
  <head>
    |\emph{...lines of edit.js...}|
    |\emph{...lines of style from knitr...}|
    <title>Example</title>
  </head>
  <body>
    |\emph{...lines of button.html}|
    <h1 contenteditable="true" id="Editor-1">Example</h1>
    <p contenteditable="true" id="Editor-2">
|\hl{c}{<strong>20 normal random variates</strong>}|
    </p>
    <p class="annotation" style = "background-color:coral">
    The text "-1.88681" was annotated with the message "Example" by "e.lim0322"
    </p>
<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">20</span><span class="hl std">)</span>
</pre></div>
<div class="output"><pre class="knitr r">##  [1] -0.21445 -0.03694  1.15209 -0.75281  0.66412 -1.14614 -0.98223
##  [8] -1.10767 -1.91184  2.00111  0.66261 -1.00241 -0.41161 -0.07720
## [15] -1.20503 -1.77474 -1.05262 -3.28418  0.76983 -1.88681
</pre></div>
</div></div>

    <!--begin.keepcode
    rnorm(20)
    end.keepcode-->
  </body>
</html>
\end{lstlisting}

The text is successfully edited in Figure \ref{fig:9}.

\begin{figure}[h]
\includegraphics[trim=0cm 19.5cm 0cm 3.2cm,clip=true,width=1.1\textwidth,center]{example1_save}
\caption{\texttt{example1.save.html} in a browser}
\label{fig:9}
\end{figure}

%------------------------------------------------------------------------------
\subsection{\texttt{rip()}}
\label{subsec:5}
The main purpose of the function \texttt{rip()} is to return to the original source document format while retaining changes and annotations. It searches for any foreign lines of code that are introduced by \textbf{knitr} or inserted during certain stages of the round trip, and removes those lines. Typically, the lines of the CSS style inserted by \textbf{knitr} are removed first, followed by the lines corresponding to the \texttt{div} elements generated and inserted by \textbf{knitr} (e.g. lines 17--23 in Listing \ref{lst:8}). These \texttt{div} elements are defined with the attribute \texttt{class="chunk"} which can be identified by \texttt{snap()} to recognise them as the elements introduced by \textbf{knitr}. Then the copies of the original R code chunks (lines 12--14 in Listing \ref{lst:3}) are modified by \texttt{snap()} to be exactly as the originals. The text ``\texttt{keep}" in the comment tags of the copy (lines 12 and 14 in Listing \ref{lst:3}) are identified and converted to the letter ``\texttt{r}" so that both the opening and closing comment tags are like the originals. The lines of \texttt{button.html} and \texttt{edit.js} are also removed as well as the two attributes \texttt{contenteditable="true"} and \texttt{id="Editor"}, added to mark up the corresponding elements as editable (Section \ref{subsec:2}).

The following R code calls the function \texttt{rip()} on the input document \texttt{example1.save.html} to generate the output document \texttt{example1.return.Rhtml}.

<<eval=FALSE>>=
source("rip.R")
rip("example1.save.html")
@

The internal code structure of the output document \texttt{example1.return.Rhtml} can be seen in Listing \ref{lst:9}. If we compare the code structure of the source document \texttt{example1.Rhtml} with that of \texttt{example1.return.Rhtml}, we can notice that line 8 in Listing \ref{lst:1} (original) is replaced by the edited text in line 9 of Listing \ref{lst:9}. Lines 11--13 in Listing \ref{lst:9} are the generated messages for the annotations from the previous step (Section \ref{subsec:3}). Apart from these lines, the rest of both documents are identical.

\begin{lstlisting}[caption={\texttt{example1.save.html}}, escapechar=\|, label={lst:9}]
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Example</h1>
    <p>
<strong>20 normal random variates</strong>
    </p>
    <p class="annotation" style = "background-color:coral">
    The text "-1.88681" was annotated with the message "Example" by "e.lim0322"
    </p>
    <!--begin.rcode
    rnorm(20)
    end.keepcode-->
  </body>
</html>
\end{lstlisting}

We can knit the ``final" source document \texttt{example1.return.Rhtml} by the following code in R.

<<eval=FALSE>>=
knit("example1.return.Rhtml")
@

The display of the knitted document \texttt{example1.return.html} through a browser can be seen in Figure \ref{fig:10}.

\begin{figure}[h]
\includegraphics[trim=0cm 22cm 0cm 0cm,clip=true,width=1.1\textwidth,center]{example1_return}
\caption{\texttt{example1.return.html} in a browser}
\label{fig:10}
\end{figure}

%------------------------------------------------------------------------------
\section{Discussion}
\label{sec:discussion}
There are a few restrictions in the round trip that need to be discussed. Some of the steps involved in the round trip base their algorithms on the assumption that \textbf{knitr} remains consistent. For example, identifying the annotatable elements (Section \ref{subsec:2}) is carried out under the assumption that these elements are always given the attribute \texttt{class="chunk"} by \textbf{knitr}. If there is to be a change in \textbf{knitr} that affects the structure of the annotatable elements, especially their attributes, the round trip will fail to complete the cycle and we will have to devise a new measure for the change.

The editing and annotating stage of the round trip is limited to what \textbf{CKEditor} and \textbf{AnnotateIT} offer as the necessary tools. The requirement by \textbf{AnnotateIT} for its user to maintain a logged-in status with their website is a restriction that can be avoided altogether by implementing a different annotator module. The overall process of editing and annotating can be more efficient and flexible to allow for more extensive document editing by the use of modules that have relatively less restrictions than \textbf{CKEditor} and \textbf{AnnotateIT}.

Furthermore the efficiency of the round trip may improve by the use of a different HTML editor. One of the main reasons behind the uploading procedure is to enable \textbf{CKEditor} without having to localise the module in the user's computing environment. If it is possible to integrate an HTML editor, into the round trip, that does not pose the localisation problem the uploading step can be omitted to make more efficient and tidier document generation and editing through the round trip possible.

By using a different HTML editor, we can also reduce some of the problems arising from the uploading stage of the round trip. Currently it is not possible to upload external files such as image files that are produced by R on the test server. As a result, any graphics included in the uploaded documents cannot be displayed through a browser. Again this issue can be avoided by using suitable HTML editors that do not require the server integration. A possible future direction of the project in regards to these limitations is in generalising the round trip so that the user gets to choose which HTML editors to use for the round trip.

There is a possibility of an alternative approach to the round trip. This would be to integrate a wiki or an online document system (e.g. Google Docs) as the main editing tool. These tools may improve the efficiency of the overall editing process through more dynamic and responsive process of document editing.

Finally, we need to consider how the sections of images, mathematical equations and general tables could be edited in a document. A possible approach to the problem is to allow annotations on them as we cannot directly interfere with the contents of these sections. A better approach would be to utilise a suitable JavaScript module written for the purpose of editing or annotating on these specific sections.

%------------------------------------------------------------------------------
\section{Conclusion}
Our ultimate goal remains to be in further generalising the round trip to suit a broader spectrum of document types. The first phase of the project has explored the possibilities of a complete round trip between the source and final documents to enhance the flow of the document generation process. So far the phase 1 round trip is strictly limited to the HTML type of documentation. However, we hope that our suggested ideas involved with each step of the round trip can be used by others to further optimise the procedures invovled in statistical document generation.

%------------------------------------------------------------------------------
\section{Contributions}
List of contributions from the project supervisor Dr Paul Murrell:
\begin{itemize}
 \item ideas
 \item \texttt{edit.js}
 \item \texttt{button.html}
\end{itemize}

\end{document}
